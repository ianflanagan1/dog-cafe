# daemon off;
worker_processes 2;             # Rule of thumb: one per CPU (auto)
                                # Align with k8s spec.resources.limit.cpu
error_log  /proc/self/fd/2 warn;
pid        /var/lib/nginx/nginx.pid;

events {
    worker_connections  1024;   # Max concurrent connections per worker
    multi_accept on;            # Allow workers to accept all pending connections at once, rather than one by one
    use epoll;                  # Linux optimization
}

http {
    include /etc/nginx/mime.types;

    log_format debug '$request_id $time_iso8601 $remote_addr $request $status $upstream_status '

                # Client/Nginx Connection
                'c=$connection '                    # Connection serial number
                'cr=$connection_requests '          # Number of requests made on this connection
                'ct=$connection_time '              # Connection time (seconds)

                # Times
                'rt=$request_time '                 # From first read to last byte sent
                'uct=$upstream_connect_time '
                'uht=$upstream_header_time '        # From first byte sent to PHP-FPM till first response header byte received by Nginx
                'urt=$upstream_response_time '      # From first byte sent to PHP-FPM till last response byte received by Nginx

                # Request size
                'rl=$request_length '               # Request line + headers + body
                'cl=$http_content_length '          # Body (from Content-Length header)
                'ubs=$upstream_bytes_sent '         # FastCGI params + request body

                # Response size
                'url=$upstream_response_length '    # FastCGI params + response body
                'bs=$bytes_sent '                   # Response bytes sent (status line + headers + body + HTTP/2 Frame Overhead)
                'bbs=$body_bytes_sent '             # Response body bytes sent
                'scl=$sent_http_content_length '    # Response body (from Content-Length header)

                '$http_referer "$http_user_agent" '
                ;

    access_log  /proc/self/fd/1 debug;

    # ephemeral storage
    client_body_temp_path /var/lib/nginx/tmp/client;
    fastcgi_temp_path     /var/lib/nginx/tmp/fastcgi;
    proxy_temp_path       /var/lib/nginx/tmp/proxy;
    scgi_temp_path        /var/lib/nginx/tmp/scgi;
    uwsgi_temp_path       /var/lib/nginx/tmp/uwsgi;

    # persistent storage
    # fastcgi_cache_path    /var/lib/nginx/cache/fastcgi levels=1:2 keys_zone=fastcgi_cache:10m inactive=60m;
    # proxy_cache_path      /var/lib/nginx/cache/proxy levels=1:2 keys_zone=proxy_cache:10m inactive=60m;

    # Rate Limiting
    limit_req_zone $binary_remote_addr zone=req_api:10m rate=30r/s;  # Rate limiting                     503 Service Unavailable
                                                                    # 30 request/second --> 1 request allowed every 33.33ms (per IP)
                                                                    # 10MB / ~64b ≈ ~160,000 records (IP, last access time, excess counters, rate buckets)
                                                                    # burst: queue size for excess requests
                                                                    # nodelay: process queue instantly (but still fill the queue for the relevant time)

    limit_conn_zone $binary_remote_addr zone=conn_api:124k;         # Limit concurrent connections      503 Service Unavailable
                                                                    # 1MB / 64b ≈ 16,384 concurrent IPs / mb
                                                                    # Required memory = Max concurrent connections * 64b
                                                                    # = worker_processes * worker_connections * 64b
                                                                    # = 2 * 1024 * 64b = 124kb

    # Performance optimizations
    sendfile on;                        # Lets Nginx send static files directly from disk
    tcp_nopush on;                      # Send headers in one piece
    tcp_nodelay on;                     # Don't buffer data-sends
    server_tokens off;                  # Prevents Nginx revealing its version in error pages and `Server:` headers

    # Uploads
    client_max_body_size 1m;            # >= php:post_max_size, >= php:upload_max_filesize          413 Request Entity Too Large    

    # Timeouts
    client_header_timeout 10s;          # Timeout for client to send request line & headers         408 Request Timeout             client timed out
    client_body_timeout 10s;            # Timeout for client to send body (incl. file upload)       408 Request Timeout             client timed out
    reset_timedout_connection on;       # Sends a TCP RST (reset) packet on `client_header_timeout` / `client_body_timeout`
                                        # Free up memory, file descriptors
    fastcgi_connect_timeout 3s;         # Timeout to establish connection to PHP-FPM                502 Bad Gateway                 upstream timed out
    fastcgi_send_timeout 10s;           # Timeout for sending request to PHP-FPM                    504 Gateway Timeout             upstream timed out      (i.e. large request, or PHP-FPM overwhelmed)
    fastcgi_read_timeout 35s;           # Timeout for reading response from PHP-FPM                 504 Gateway Timeout             upstream timed out (110: Operation timed out) while reading response header from upstream
                                        # >= php-fpm:request_terminate_timeout                      If PHP times out first: 500
                                        # >= php:max_execution_time                                 If PHP times out first: 500
    send_timeout 30s;                   # Timeout for sending response to client                    504 Gateway Timeout             client was aborted

    # Client -> Nginx
    client_header_buffer_size 1k;       # Memory for request line & headers. If insufficient, use `large_client_header_buffers` instead
    large_client_header_buffers 4 4k;   # Larger memory for request line & headers. If exceeded:    400 Bad Request                 client sent too large header   or   header too large
    client_body_buffer_size 128k;       # Memory for request body. Excess to `client_body_temp_path`

    # Nginx -> PHP-FPM
    fastcgi_request_buffering on;       # Read entire request before sending to PHP-FPM
                                        # If off, $_POST, $_FILES will be empty or incomplete; must read from php://input

    # PHP-FPM -> Nginx
    fastcgi_buffering on;               # Read entire response before sending to client
                                        # Align with php:output_buffering, php:implicit_flush
    fastcgi_buffer_size 32k;            # Memory for response first part. If headers exceed:        502 Bad Gateway                 upstream sent too big header while reading response header from upstream   or   upstream sent invalid header
    fastcgi_buffers 8 32k;              # Memory for remaining (non-header) response.
                                        # Excess to `fastcgi_temp_path`
    fastcgi_max_temp_file_size 100m;    # When `fastcgi_buffers` exceed, maximum file size.         502 Bad Gateway                 temp file write error
    fastcgi_temp_file_write_size 32k;   # When `fastcgi_buffers` exceed, how much to write to disk at once (write chunking)
                                        # >= max(fastcgi_buffer_size, fastcgi_buffers)
    fastcgi_busy_buffers_size 64k;      # "busy" means Nginx received the entire response from PHP-FPM, but client yet to confirm received the entire response
                                        # Don't let a slow-receiving client consume lots of memory / temp disk space
                                        # While `fastcgi_busy_buffers_size` exceeded, Nginx stops reading from PHP-FPM; Risks triggering `fastcgi_read_timeout`
                                        # Default is 2 * fastcgi_buffer_size (i.e. 2 buffers)

    fastcgi_keep_conn on;               # Note: relevant for both TCP and socket connection

    # HTTP compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;          # 1-9, 6 is balanced
    gzip_buffers 16 8k;         # Buffer size for compression
    gzip_types
        application/json
        application/javascript
        application/xml
        application/xml+rss
        text/plain
        text/css
        text/javascript
        text/xml
        image/svg+xml;          # SVG is text-based, compressible
    gzip_disable "msie6";       # Disable for very old IE

    # External traffic
    server {
        listen 80;
        listen [::]:80;

        root /static/;

        limit_conn conn_api 40;
        limit_req zone=req_api burst=40 nodelay;

        keepalive_timeout 30s;  # Max life of a keepalive connection
        keepalive_requests 100; # Max requests over a keepalive connection

        charset UTF-8;
        default_type application/json;

        # Static assets
        location = /robots.txt {
            access_log off;
            add_header X-Content-Type-Options "nosniff" always;                     # Global header
            add_header Cache-Control "public, max-age=3600" always;                 # Cache: 1 hour
        }

        location ~ ^/favicon\.ico$|^/(images|js|css|sh/user)/ {
            access_log off;
            gzip_static on;
            add_header X-Content-Type-Options "nosniff" always;                     # Global header
            add_header Cache-Control "public, max-age=31536000, immutable" always;  # Cache: 1 year immutable
        }

        # Block admin endpoints
        location ~ ^/(php-fpm-status|php-fpm-ping) {
            return 404;
            add_header X-Content-Type-Options "nosniff" always;                     # Global header
            add_header Cache-Control "public, max-age=31536000, immutable" always;  # Cache: 1 year immutable
        }

        # PHP
        location ~ ^/(settings|logout|account|docs|favs|suggest|login|redirect-google-login|redirect-discord-login)?$|^/(api/v1|list|map|venue)(/|$) {
            add_header X-Content-Type-Options "nosniff" always;                     # Global header
            add_header Cache-Control "no-cache, no-store, must-revalidate" always;  # Cache: none

            # HTML-specific headers
            add_header Referrer-Policy "strict-origin-when-cross-origin" always;
            add_header Content-Security-Policy "base-uri 'self'; form-action 'self'; frame-ancestors 'none'; default-src 'none'; style-src 'self' https://fonts.googleapis.com; script-src 'self' https://maps.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' https://maps.gstatic.com https://maps.googleapis.com data:; connect-src 'self' https://maps.googleapis.com" always;

            fastcgi_pass    dog-cafe-php:9000;
            include         fastcgi_params;
            fastcgi_param   SCRIPT_FILENAME     /app/public/index.php;
            fastcgi_param   HTTP_X_REQUEST_ID   $request_id;
            fastcgi_param   HTTP_PROXY          "";
        }
    }

    include /etc/nginx/conf.d/*.conf;
}

# Max memory per connection (Request)  = client_header_buffer_size + large_client_header_buffers + large_client_header_buffers number * size + client_body_buffer_size
# Max memory per connection (Response) = fastcgi_buffer_size + fastcgi_buffers number * size
# Nginx overhead            = Master process overhead + workers * Worker process overhead + shared memory zones
# Shared memory zones       = proxy_cache_path + fastcgi_cache_path + limit_req_zone + limit_conn_zone + ssl_session_cache + sticky session zones

# Max total memory usage    = Max memory per connection (Request+Response) * worker_connections * workers + Nginx overhead
#                           = ( 1k + 4*4k + 128k + 32k + 8*32k ) * 1024 * 2 + 10mb
#                           = 443392 * 1024 * 2 + 10mb
#                           = 908066816 + 10mb
#                           = 918552576
#                           = 876mb